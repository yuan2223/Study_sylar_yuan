## 协程模块
### 协程和线程的区别
* 在单线程内，协程不能并发，只能一个协程执行完或者yield后，在执行另外一个协程
* 不要在协程里面使用线程级别的锁来做协程同步，比如pthread_mutex_t,如果一个协程在持有锁之后yield让出执行，那么同线程的任何其他协程一旦尝试持有该锁，整个线程就锁死。和单线程下连续两次对同一个锁进行加锁导致死锁一样。
* 线程创建后，线程的运行和调度都是由操作系统完成，而协程是由应用程序控制
 ### ucontext_t的接口
 ```cpp
typedef struct ucontext_t{
    struct ucontext_t* uc_link;
    sigset_t uc_sigmask;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
};

int getcontext(ucontext_t* ucp);    //获取当前的上下文

//makecontext执行完毕后，ucp与func绑定,调用swapcontext激活ucp时,func会被运行。
void makecontext(ucontext_t* ucp, void(*func)(),int arc, ...);

//上下文的切换
int swapcontext(ucontext_t* ocup,const ucontext_t* ucp);
 ```

```cpp
    Scheduler sc;   //创建调度器
    sc(&func);      //添加任务 
        ...
    sc.start();     //开始调度
    sc.top();
```

### 协程模块设计
* 使用非对称模型，也就是子协程只能和主协程切换，不能和另一个子协程切换，在程序结束时，一定回到主协程。
线程局部变量和全局变量类似，不同之处在于线程局部变量在每个线程都独有一份，而全局变量是全部线程共享一份。
```cpp
static thread_local Fiber* t_fiber = nullptr;   //线程局部变量，当前线程正在运行的协程
static thread_local Fiber::ptr t_thread_fiber = nullptr;//当前线程的主协程
```

## 协程调度模块
### 调度器如何运行

 * Scheduler初始化时，传入线程数threads,use_caller参数，use_call = true表示 main函数所在的线程参与调度，并且会初始化一个属于caller线程的调度协程
 * 调度器创建后，可以向调度器中使用(scheduler)方法添加任务，并保存在任务队列中，并不会马上执行.
 * 调度协程对应run方法。调度协程从任务队列中取任务，取出的任务就是子协程，每个子协程执行完后都回到调度协程，调度协程在重新从任务队列中取任务执行。如果任务队列为空，调度协程会切换到idle协程，等有新任务在从idle协程退出回到调度协程。
 * 在非caller线程里，调度协程就是调度线程的主协程，但在caller线程里，调度协程并不是caller线程的主协程。
 * scheduler方法是添加调度任务，支持传入协程，函数，并且可以传入一个线程号参数，绑定到这个线程执行。如果调度任务为空，在添加任务后，要调用tickle()方法通知个调度线程的调度协程有新任务。
 * 调度器的停止，如果use_caller = true,在调度器停止之前，这个caller线程的调度协程也要运行一次，让call线程完成调度。

对调度器来说，函数，协程都可以作为调度任务，因为函数也是可执行的对象，可以把函数包装成协程。
协程调度就是创建一批协程对象，然后在创建一个调度协程，在通过调度协程把这些协程对象一个一个消化掉。
IO协程调度就是在调度协程时，发现这个协程在等待IO就绪，那就让这个协程让出执行权，等待对应的IO就绪在重新恢复这个协程的运行。
定时器就是给调度协程预设一个协程对象，等定时时间到了就恢复预设定的对象。

### 调度协程如何切换
#### 线程数为1,use_caller = true的情况
主要有main函数对应的主协程，调度协程，待调度的任务协程
执行顺序是：
* mian函数主协程运行，创建调度器 
* mian函数主协程运行，添加调度任务 
* 开始协程调度，main函数让出执行权，切换到调度协程，调度协程从任务队列按顺序执行完所有的任务 
* 每次执行完一个任务，调度协程都要让出执行权，在切换到任务协程运行，任务执行结束，在切换到调度协程，继续下一个任务的调度 
* 所有任务执行完，调度协程还要让出执行权并回到main函数主协程。
### 其他问题
* 如果任务队列还有任务剩余，规定所有任务执行完调度器才可以退出
* 任务协程在执行过程中主动yield，调度器认为该任务已经完成，如果该任务协程要完整的执行该任务，那么在yield之前，那么该协程必须在yield之前把自己扔回当前调度器的调度协程，确保后面还会执行这个协程。
* 如果调度器没有任务调度时，调度协程会不停的检测任务队列，看看有没有新任务，CPU使用率提高。
## IOManager模块
继承协程调度器，封装了epoll，支持为Socket fd注册读写时间回调函数。解决了调度器在idle状态下导致CPU占用率高的问题。

IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，添加新任务时，tickle方法写管道,idle协程检测到管道可读后退出，调度器执行调度。

IOManager调度模块基于epoll实现，只支持Linux平台，对每个fd支持可读事件(EPOLLIN)和可写事件(WPOLLOUT)。
对IO协程调度来说，每次调第都包含三个信息：描述符-事件类型(可读或可写)-回调函数，调度器记录全部需要调度的三组信息，其中描述符和事件类型用于epoll_wait，回调函数用于协程，三个信息通过FdContext结构体保存，在执行epoll_wait时，epoll_event的私有数据指针data.ptr来保存FdContext结构体信息。

IO协程调度器在idel时会epoll_wait所有注册的fd，如果有fd满足条件，epoll_wait返回，从私有数据中拿到fd的上下文信息，并执行其中的回调函数。事件idle协程只负责收集所有已触发的fd的回调函数并将其加入到调度器的任务队列，真正执行是idle协程退出后，调度器在下一轮调度时执行。

与协程调度器不一样的是，IO协程调度器支持取消事件，表示不关心某个fd的事件了，这个fd的可读可写事件都被取消，那这个fd会从调度器的epoll_Wait中删除。

### IO协程调度器
* 第一部分是对协程调度器进行改造，将epoll与协程调度融合，重新实现tickle和idle，并保证原有功能不变，第二部分是基于epoll实现IO事件的添加，删除，调度和取消功能。
* epoll是线程安全的，即使调度器有多个调度线程，也可也共用一个epoll实例，不用担心互斥问题，由于空闲时所有线程都阻塞在epoll_wait上，不用担心CPU占用问题。
* addEvent是一次性的，注册了一个读事件，当fd可读时会触发该事件，但触发完之后，这次注册的事件就失效了，后面fd再次可读时，并不会继续执行该事件回调，如果要持续触发事件的回调，那每次事件处理完都要手动再addEvent。

......






